[
  {
    "id": "platform.core.search",
    "type": "builtin",
    "description": "A powerful tool for searching and analyzing data within your Elasticsearch cluster.\nIt supports both full-text relevance searches and structured analytical queries.\n\nUse this tool for any query that involves finding documents, counting, aggregating, or summarizing data from a known index.\n\nExamples of queries:\n- \"find articles about serverless architecture\"\n- \"search for support tickets mentioning 'billing issue' or 'refund request'\"\n- \"what is our policy on parental leave?\"\n- \"list all products where the category is 'electronics'\"\n- \"show me the last 5 documents from that index\"\n- \"show me the sales over the last year break down by month\"\n\nNote:\n- The 'index' parameter can be used to specify which index to search against.\n If not provided, the tool will decide itself which is the best index to use.\n- It is perfectly fine not to specify the 'index' parameter. It should only be specified when you already\n know about the index and fields you want to search on, e.g. if the user explicitly specified it.\n    ",
    "tags": [],
    "configuration": {},
    "readonly": true
  },
  {
    "id": "platform.core.get_document_by_id",
    "type": "builtin",
    "description": "Retrieve the full content (source) of an Elasticsearch document based on its ID and index name.",
    "tags": [],
    "configuration": {},
    "readonly": true
  },
  {
    "id": "platform.core.execute_esql",
    "type": "builtin",
    "description": "Execute an ES|QL query and return the results in a tabular format.\n\n**IMPORTANT**: This tool only **runs** queries; it does not write them.\nThink of this as the final step after a query has been prepared.\n\nYou **must** get the query from one of two sources before calling this tool:\n1.  The output of the `platform.core.generate_esql` tool (if the tool is available).\n2.  A verbatim query provided directly by the user.\n\nUnder no circumstances should you invent, guess, or modify a query yourself for this tool.\nIf you need a query, use the `platform.core.generate_esql` tool first.",
    "tags": [],
    "configuration": {},
    "readonly": true
  },
  {
    "id": "platform.core.generate_esql",
    "type": "builtin",
    "description": "Generate an ES|QL query from a natural language query.",
    "tags": [],
    "configuration": {},
    "readonly": true
  },
  {
    "id": "platform.core.get_index_mapping",
    "type": "builtin",
    "description": "Retrieve mappings for the specified index or indices.",
    "tags": [],
    "configuration": {},
    "readonly": true
  },
  {
    "id": "platform.core.list_indices",
    "type": "builtin",
    "description": "List the indices, aliases and datastreams from the Elasticsearch cluster.\n\nThe 'pattern' optional parameter is an index pattern which can be used to filter resources.\nThis parameter should only be used when you already know of a specific pattern to filter on,\ne.g. if the user provided one. Otherwise, do not try to invent or guess a pattern.",
    "tags": [],
    "configuration": {},
    "readonly": true
  },
  {
    "id": "platform.core.index_explorer",
    "type": "builtin",
    "description": "List relevant indices, aliases and datastreams based on a natural language query.\n\nThe 'indexPattern' parameter can be used to filter indices by a specific pattern, e.g. 'foo*'.\nThis should *only* be used if you know what you're doing (e.g. if the user explicitly specified a pattern).\nOtherwise, leave it empty to search against all indices.\n\n*Example:*\nUser: \"Show me my latest alerts\"\nYou: call tool 'index_explorer' with { query: 'indices containing user alerts' }\nTool result: [{ type: \"index\", name: '.alerts' }]\n",
    "tags": [],
    "configuration": {},
    "readonly": true
  },
  {
    "id": "search_for_parents",
    "type": "esql",
    "description": "Based on inputs to search a person's parent",
    "tags": [],
    "configuration": {
      "query": "FROM people METADATA _score | WHERE MATCH(description, ?profession) OR MATCH(des_semantic, ?profession)\n| LOOKUP JOIN parents ON id",
      "params": {
        "profession": {
          "type": "text",
          "description": "a person's job title",
          "optional": false
        }
      }
    },
    "readonly": false
  },
  {
    "id": "software_developers",
    "type": "esql",
    "description": " Retrieve all the software developers from people index",
    "tags": [],
    "configuration": {
      "query": " FROM people METADATA _score | WHERE MATCH(description, \"software developer\")",
      "params": {}
    },
    "readonly": false
  },
  {
    "id": "people_profession_search",
    "type": "esql",
    "description": "Search for the document for people index based on its profession input.",
    "tags": [
      "analytics",
      "people",
      "updated"
    ],
    "configuration": {
      "query": "FROM people METADATA _score | WHERE MATCH(description, ?profession) OR MATCH(des_semantic, ?profession) | SORT _score DESC | LIMIT 1",
      "params": {
        "profession": {
          "type": "text",
          "description": "profession for search results",
          "optional": false
        }
      }
    },
    "readonly": false
  },
  {
    "id": "find_people_in_ages",
    "type": "esql",
    "description": "Search for the people between ages",
    "tags": [],
    "configuration": {
      "query": "    FROM people\n    | WHERE age >= ?start_age AND age <= ?end_age\n    | SORT age desc\n    | LIMIT 10",
      "params": {
        "start_age": {
          "type": "integer",
          "description": "minimum age to search for",
          "optional": false
        },
        "end_age": {
          "type": "integer",
          "description": "maximum age to search for",
          "optional": false
        }
      }
    },
    "readonly": false
  },
  {
    "id": "find_people_in_time_range",
    "type": "esql",
    "description": "Search for the people whose date_of_birth are within a period of time",
    "tags": [
      "analytics"
    ],
    "configuration": {
      "query": "    FROM people\n    | WHERE date_of_birth >= TO_DATETIME(?start) AND date_of_birth <= TO_DATETIME(?end)\n    | LIMIT 3",
      "params": {
        "start": {
          "type": "date",
          "description": "beginning of the period to look at",
          "optional": false
        },
        "end": {
          "type": "date",
          "description": "end of the period to look at",
          "optional": false
        }
      }
    },
    "readonly": false
  },
  {
    "id": "find_client_exposure_to_negative_news",
    "type": "esql",
    "description": "Finds client portfolio exposure to negative news. This tool scans recent news and reports for negative sentiment, identifies the associated asset, and finds all clients holding that asset. It returns a list sorted by the current market value of the position to highlight the highest potential risk.",
    "tags": [
      "retrieval",
      "risk-analysis"
    ],
    "configuration": {
      "query": "\n        FROM financial_news, financial_reports METADATA _index\n        | WHERE sentiment == \"negative\"\n        | WHERE coalesce(published_date, report_date) >= NOW() - TO_TIMEDURATION(?time_duration)\n        | RENAME primary_symbol AS symbol\n        | LOOKUP JOIN financial_asset_details ON symbol\n        | LOOKUP JOIN financial_holdings ON symbol\n        | LOOKUP JOIN financial_accounts ON account_id\n        | WHERE account_holder_name IS NOT NULL\n        | EVAL position_current_value = quantity * current_price.price\n        | RENAME title AS news_title\n        | KEEP\n            account_holder_name, symbol, asset_name, news_title,\n            sentiment, position_current_value, quantity, current_price.price,\n            published_date, report_date\n        | SORT position_current_value DESC\n        | LIMIT 50\n      ",
      "params": {
        "time_duration": {
          "type": "keyword",
          "description": "The timeframe to search back for negative news. Format is \"X hours\" DEFAULT TO 8760 hours "
        }
      }
    },
    "readonly": false
  },
  {
    "id": "find_cheapest_ticket_from_cn_us",
    "type": "esql",
    "description": "Find the cheapest air-ticket from China to US.",
    "tags": [],
    "configuration": {
      "query": "      FROM kibana_sample_data_flights METADATA _score\n      | WHERE MATCH(OriginCountry, \"CN\") AND MATCH(DestCountry, \"US\")\n      | SORT AvgTicketPrice ASC\n      | KEEP AvgTicketPrice, OriginCityName, DestCityName\n      | LIMIT 1      ",
      "params": {}
    },
    "readonly": false
  },
  {
    "id": "example-esql-tool",
    "type": "esql",
    "description": "An ES|QL query tool for analyzing financial trades with time filtering",
    "tags": [
      "analytics",
      "finance",
      "updated"
    ],
    "configuration": {
      "query": "FROM financial_trades | WHERE execution_timestamp >= ?startTime | STATS trade_count=COUNT(*), avg_price=AVG(execution_price) BY symbol | SORT trade_count DESC | LIMIT ?limit",
      "params": {
        "startTime": {
          "type": "date",
          "description": "Start time for the analysis in ISO format"
        },
        "limit": {
          "type": "integer",
          "description": "Maximum number of results to return"
        }
      }
    },
    "readonly": false
  },
  {
    "id": "find_average_age",
    "type": "esql",
    "description": "Calculate the average age of the people index",
    "tags": [],
    "configuration": {
      "query": "FROM people | STATS AVG(age)",
      "params": {}
    },
    "readonly": false
  }
]